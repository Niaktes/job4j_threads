package ru.job4j.atomicity;

public class DCLSingleton {

    private static volatile DCLSingleton inst;

    public static DCLSingleton instOf() {
        if (inst == null) {
            synchronized (DCLSingleton.class) {
                if (inst == null) {
                    inst = new DCLSingleton();
                }
            }
        }
        return inst;
    }

    private DCLSingleton() {
    }

}
/*
В случае, если переменная не volatile, вторая проверка может обратиться к переменным в разных участках памяти.
Т.е. представим себе, что у нас два потока проходят первую проверку на null и утыкаются в синхронизацию. Одна из нитей останавливается и ждёт пока вторая доделает своё дело внутри синхронизированного участка кода. Вроде всё нормально.
Однако, если одна из нитей проведёт свои манипуляции с переменной, запишет в неё адрес объекта в RAM, освободит класс, а вторая нить будет проверять переменную где и проверяла, например, в CPU Cache.
Ну и опять можно получить в результате две ссылки на два разных объекта.
 */